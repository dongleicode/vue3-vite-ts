#vue源码解读：
## 1 vue2变化侦测篇
### 1.1 综述
Vue最大的特点之一就是数据驱动视图
UI = render(state)

上述公式中：状态state是输入，页面UI输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。
**Vue是怎么知道state变化了呢，换句话说，数据变化了是怎么通知给Vue呢？**
- 什么是变化侦测（状态跟踪）
- 在Angular中是通过脏值检查流程来实现变化侦测；
- 在React是通过对比虚拟DOM来实现变化侦测，
- 而在Vue中也有自己的一套变化侦测实现机制。

### 1.2 Object的变化侦测
我们通过Object.defineProperty方法实现了对object数据的可观测，并且封装了Observer类，让我们能够方便的把object数据中的所有属性（包括子属性）都转换成getter/seter的形式来侦测变化。

接着，我们学习了什么是依赖收集？并且知道了在getter中收集依赖，在setter中通知依赖更新，以及封装了依赖管理器Dep，用于存储收集到的依赖。

最后，我们为每一个依赖都创建了一个Watcher实例，当数据发生变化时，通知Watcher实例，由Watcher实例去做真实的更新操作。

其整个流程大致如下：

- Data通过observer转换成了getter/setter的形式来追踪变化。
- 当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。
- 当数据发生了变化时，会触发setter，从而向Dep中的依赖（即Watcher）发送通知。
- Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。

### 1.3 Array的变化侦测
#### 1.3.1 在哪里收集依赖
Array型数据还是在getter中收集依赖
#### 1.3.2 数组方法拦截器
在Vue中创建了一个数组方法拦截器，它拦截在数组实例与Array.prototype之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用Array.prototype上的原生方法。如下图所示：
![数组拦截器](img/%E6%95%B0%E7%BB%84%E6%8B%A6%E6%88%AA%E5%99%A8.png)
经过整理，Array原型中可以改变数组自身内容的方法有7个，分别是：push,pop,shift,unshift,splice,sort,reverse。那么源码中的拦截器代码如下：
    // 源码位置：/src/core/observer/array.js
    const arrayProto = Array.prototype
    // 创建一个对象作为拦截器
    export const arrayMethods = Object.create(arrayProto)

    // 改变数组自身内容的7个方法
    const methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
    ]

    /**
    * Intercept mutating methods and emit events
    */
    methodsToPatch.forEach(function (method) {
    const original = arrayProto[method]      // 缓存原生方法
    Object.defineProperty(arrayMethods, method, {
        enumerable: false,
        configurable: true,
        writable: true,
        value:function mutator(...args){
        const result = original.apply(this, args)
        return result
        }
    })
    })

#### 1.3.3 使用拦截器
其实挂载不难，我们只需把数据的__proto__属性设置为拦截器arrayMethods即可，源码实现如下：

    // 源码位置：/src/core/observer/index.js
    export class Observer {
    constructor (value) {
        this.value = value
        if (Array.isArray(value)) {
        const augment = hasProto
            ? protoAugment
            : copyAugment
        augment(value, arrayMethods, arrayKeys)
        } else {
        this.walk(value)
        }
    }
    }
    // 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性
    export const hasProto = '__proto__' in {}

    const arrayKeys = Object.getOwnPropertyNames(arrayMethods)

    /**
    * Augment an target Object or Array by intercepting
    * the prototype chain using __proto__
    */
    function protoAugment (target, src: Object, keys: any) {
    target.__proto__ = src
    }

    /**
    * Augment an target Object or Array by defining
    * hidden properties.
    */
    /* istanbul ignore next */
    function copyAugment (target: Object, src: Object, keys: Array<string>) {
    for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i]
        def(target, key, src[key])
    }
    }

上面代码中首先判断了浏览器是否支持__proto__，如果支持，则调用protoAugment函数把value.__proto__ = arrayMethods；如果不支持，则调用copyAugment函数把拦截器中重写的7个方法循环加入到value上
#### 1.3.4 再谈依赖收集
在Observer类中实例化了一个依赖管理器，用来收集数组依赖。
我们首先通过observe函数为被获取的数据arr尝试创建一个Observer实例，在observe函数内部，先判断当前传入的数据上是否有__ob__属性，因为在上篇文章中说了，如果数据有__ob__属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用new Observer(value)将其转化成响应式的，并把数据对应的Observer实例返回。
而在defineReactive函数中，首先获取数据对应的Observer实例childOb，然后在getter中调用Observer实例上依赖管理器，从而将依赖收集起来。
最后，调用依赖管理器的dep.notify()方法，让它去通知依赖更新即可。
#### 1.3.5 不足之处
我们在日常开发中，还可以通过数组的下标来操作数据，如下：

    let arr = [1,2,3]
    arr[0] = 5;       // 通过数组下标修改数组中的数据
    arr.length = 0    // 通过修改数组长度清空数组

而使用上述例子中的操作方式来修改数组是无法侦测到的。 同样，Vue也注意到了这个问题， 为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete，这两个API的实现原理将会在后面学习全局API的时候说到。
