<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>浅相应与神响应</title>
    <style>

    </style>
</head>
<body>
    <script>
        const bucket = new WeakMap()

        let activeEffect;

        const effectStack = [] //新增effect栈

        //追踪和收集依赖
        function track(target, key){
            //没有activeEffect, 直接return
            if(!activeEffect) return
            let depsMap = bucket.get(target)
            if(!depsMap){
                bucket.set(target, (depsMap = new Map()))
            }

            let deps = depsMap.get(key)
            if(!deps){
                depsMap.set(key, (deps = new Set()))
            }

            deps.add(activeEffect)
            activeEffect.deps.push(deps)
        }

        //触发副作用函数重新执行
        function trigger(target, key, type) {
            const depsMap = bucket.get(target)
            if(!depsMap){return}
            const effects = depsMap.get(key)
            const effectsToRun = new Set()
            effects && effects.forEach(effectFn => {//避免无限递归
                if(effectFn !== activeEffect){
                    effectsToRun.add(effectFn)
                }
            })
            if(type === 'ADD' || type === 'DELETE'){
                const iterateEffects = depsMap.get(ITERATE_KEY)
                iterateEffects && iterateEffects.forEach(effectFn => {//避免无限递归
                if(effectFn !== activeEffect){
                    effectsToRun.add(effectFn)
                }
            })
            }
           
            effectsToRun.forEach(effectFn => {
                if(effectFn.options.scheduler){
                    effectFn.options.scheduler(effectFn)
                }else{
                    effectFn()
                }
            })
        }


        //避免副作用函数产生遗留
        function cleanup(effectFn) {
                    for(let i = 0; i < effectFn.deps.length; i++){
                const deps = effectFn.deps[i] 
                deps.delete(effectFn)
            }
            effectFn.deps.length = 0
        }

        //用来注册副作用函数，同时它也允许指定一些选项参数options，例如指定scheduler调度器来控制副作用函数的执行时机和方式
        function effect(fn, options = {}) {
            const effectFn = () => {
                cleanup(effectFn)
                activeEffect = effectFn
                //在调用副作用函数之前将当前副作用函数压入栈顶
                //栈就是一个桶，后进先出，后进者在栈顶
                effectStack.push(effectFn)  
                const res = fn()
                //在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值
                effectStack.pop() //删除数组最后一个元素，并返回该元素
                activeEffect = effectStack[effectStack.length - 1]
                return res
            }
            effectFn.options = options
            effectFn.deps = []
            if(!options.lazy){
                effectFn()
            }
            return effectFn
        }




        const ITERATE_KEY = Symbol()

        function reactive(obj) { //深响应
            return createReactive(obj)
        }

        function shallowReactive(obj){//浅响应
            return createReactive(obj, true);
        }

        function createReactive(obj, isShallow = false) {
            return new Proxy(obj, {
                get(target, key, receiver){
                    if(key === 'raw'){
                        return target
                    }
                    const res = Reflect.get(target, key, receiver)
                    track(target, key)
                    if(isShallow){
                        return res
                    }
                    if(typeof res === 'object' && res !== null){//深响应
                        return reactive(res)
                    }
                    return res
                    
                },
                set(target, key, newV, receiver){
                    // target 是原始对象 proto
                    // receiver 仍然是代理对象 child,不再是target的代理对象
                    const oldV = target[key]
                    const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
                    const res = Reflect.set(target, key, newV, receiver)

                    if(target === receiver.raw){
                    // 比较新值与旧值，只有当它们不全等，并且不都是NaN的时候才触发响应
                        if(oldV !== newV && (oldV === oldV || newV === newV)){
                            trigger(target, key, type)
                        }
                    }
                    
                    return res
                },
                deleteProperty(target, key){
                    const hadKey = Object.prototype.hasOwnProperty.call(target, key)
                    const res = Reflect.deleteProperty(target, key)
                    if(res && hadKey){
                        trigger(target, key, 'DELETE')
                    }
                    return res
                },
                has(target, key){
                    track(target, key)
                    return Reflect.has(target, key)
                },
                ownKeys(target){
                    track(target, ITERATE_KEY)
                    // trigger(target, ITERATE_KEY)
                    return Reflect.ownKeys(target)
                }
            })
        }


        const obj = reactive({foo: {bar: 1}})

        effect(() => {
            console.log(obj.foo.bar) //1
        })
        obj.foo = {bar: 2}  //深响应,不能出发响应
        obj.foo.bar = 3 



        const obj1 = shallowReactive({foo: {bar: 1}})
        effect(() => {
            console.log(obj1.foo.bar) //1
        })
        obj1.foo = {bar: 2}  //浅响应,第一层会发出响应
        obj1.foo.bar = 3  //深层,不能触发响应

    </script>
</body>
</html>