<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>如何代理Object</title>
    <style>

    </style>
</head>
<body>
    <script>
        const bucket = new WeakMap()

        let activeEffect;

        const effectStack = [] //新增effect栈

        //追踪和收集依赖
        function track(target, key){
            //没有activeEffect, 直接return
            if(!activeEffect) return
            let depsMap = bucket.get(target)
            if(!depsMap){
                bucket.set(target, (depsMap = new Map()))
            }

            let deps = depsMap.get(key)
            if(!deps){
                depsMap.set(key, (deps = new Set()))
            }

            deps.add(activeEffect)
            activeEffect.deps.push(deps)
        }

        //触发副作用函数重新执行
        function trigger(target, key, type) {
            const depsMap = bucket.get(target)
            if(!depsMap){return}
            const effects = depsMap.get(key)
            const effectsToRun = new Set()
            effects && effects.forEach(effectFn => {//避免无限递归
                if(effectFn !== activeEffect){
                    effectsToRun.add(effectFn)
                }
            })
            if(type === 'ADD' || type === 'DELETE'){
                const iterateEffects = depsMap.get(ITERATE_KEY)
                iterateEffects && iterateEffects.forEach(effectFn => {//避免无限递归
                if(effectFn !== activeEffect){
                    effectsToRun.add(effectFn)
                }
            })
            }
           
            effectsToRun.forEach(effectFn => {
                if(effectFn.options.scheduler){
                    effectFn.options.scheduler(effectFn)
                }else{
                    effectFn()
                }
            })
        }


        //避免副作用函数产生遗留
        function cleanup(effectFn) {
                    for(let i = 0; i < effectFn.deps.length; i++){
                const deps = effectFn.deps[i] 
                deps.delete(effectFn)
            }
            effectFn.deps.length = 0
        }

        //用来注册副作用函数，同时它也允许指定一些选项参数options，例如指定scheduler调度器来控制副作用函数的执行时机和方式
        function effect(fn, options = {}) {
            const effectFn = () => {
                cleanup(effectFn)
                activeEffect = effectFn
                //在调用副作用函数之前将当前副作用函数压入栈顶
                //栈就是一个桶，后进先出，后进者在栈顶
                effectStack.push(effectFn)  
                const res = fn()
                //在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值
                effectStack.pop() //删除数组最后一个元素，并返回该元素
                activeEffect = effectStack[effectStack.length - 1]
                return res
            }
            effectFn.options = options
            effectFn.deps = []
            if(!options.lazy){
                effectFn()
            }
            return effectFn
        }




        const ITERATE_KEY = Symbol()

        function reactive(obj) {
            return new Proxy(obj, {
            get(target, key, receiver){
                if(key === 'raw'){
                    return target
                }
                track(target, key)
                //Reflect.get(target, key, receiver)代替之前的target[key]，这里的关键点就是第三个参数receiver。我们已经知道它就是代理对象p，所以访问器属性bar的getter函数内的this指向代理对象p：
                return Reflect.get(target, key, receiver)
                //this由原始对象obj变成了代理对象p。很显然，这会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集的效果。如果此时再对p.foo进行自增操作，会发现已经能够触发副作用函数重新执行了
            },
            set(target, key, newV, receiver){
                // target 是原始对象 proto
                // receiver 仍然是代理对象 child,不再是target的代理对象
                const oldV = target[key]
                const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
                const res = Reflect.set(target, key, newV, receiver)

                if(target === receiver.raw){
                   // 比较新值与旧值，只有当它们不全等，并且不都是NaN的时候才触发响应
                    if(oldV !== newV && (oldV === oldV || newV === newV)){
                        trigger(target, key, type)
                    }
                }
                
                return res
            },
            deleteProperty(target, key){
                const hadKey = Object.prototype.hasOwnProperty.call(target, key)
                const res = Reflect.deleteProperty(target, key)
                if(res && hadKey){
                    trigger(target, key, 'DELETE')
                }
                return res
            },
            has(target, key){
                track(target, key)
                return Reflect.has(target, key)
            },
            ownKeys(target){
                track(target, ITERATE_KEY)
                // trigger(target, ITERATE_KEY)
                return Reflect.ownKeys(target)
            }
        })
        }



        // //但在响应系统中，“读取”是一个很宽泛的概念，例如使用in操作符检查对象上是否具有给定的key也属于“读取”操作
        // effect(() => {
        //     console.log(p.foo);
        //     // for(const key in p){
        //     //     console.log(key);  //foo bar
        //     // }
        // })
        // p.age = 18  //foo bar age

        // const TriggerType = {
        //     SET: 'SET',
        //     ADD: 'ADD'
        // }

        // // delete p.foo
        // // console.log(p.foo); //undefined
        
        // // p.foo = 1
        // // p.foo = 1  //二次赋值和上次一样，不触发数据响应

        // p.foo = NaN


        const obj = {}
        const proto = {bar: 1}
        const child = reactive(obj)
        const parent = reactive(proto)

        //使用Object.setPrototypeOf方法将parent设置为child的原型
        Object.setPrototypeOf(child, parent)

        effect(() => {
            console.log(child.bar) // 1
        })

        child.bar = 2 // 2 2
        //代理对象可以通过raw属性读取原始数据
        console.log(child.raw === obj);//true
        console.log(parent.raw === proto);//true


    </script>
</body>
</html>