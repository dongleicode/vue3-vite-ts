<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>如何代理Set和Map</title>
    <style>

    </style>
</head>
<body>
    <script src="js/common.js"></script>
    <script>
        const obj = {foo: 1}
        obj.foo  //读取属性
        obj.foo = 2 //设置属性
        // console.log(obj);
        

        const map = new Map()
        map.set('key', 1)  //设置数据
        map.get('key')     //读取数据
        // console.log(map.get('key'));


        const s = new Set([1, 2, 3])
        const p = new Proxy(s, {
            get(target, key, receiver){
                if(key === 'size'){
                    return Reflect.get(target, key, target)
                }
                return target[key].bind(target) //需要把delete方法与原始数据对象绑定即可
                // return Reflect.get(target, key, receiver)
            },
            deleteProperty(target, key){
                return Reflect.deleteProperty(target, key)
            }
        })
        // console.log(p.size); //3
        // p.delete(1) //Method Set.prototype.delete called on incompatible receiver
        // console.log(p); //2







        //实现结果：
        const proxy = reactive(new Map([['key',1]]))
        effect(() => {
            console.log(proxy.get('key'))
        })

        // proxy.set('key', 2)
        // console.log(proxy.get('key'))


        const p2 = reactive(s)
        effect(() => {
            console.log(p2.size); //3
        })
        p2.add(1)


    </script>
</body>
</html>