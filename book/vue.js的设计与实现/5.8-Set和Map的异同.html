<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>Set和Map的异同</title>
    <style>

    </style>
</head>
<body>
    <script>
        /**
         * 集合类型包括Map/Set以及WeakMap/WeakSet。使用Proxy代理集合类型的数据不同于代理普通对象，因为集合类型数据的操作与普通对象存在很大的不同。下面总结了Set和Map这两个数据类型的原型属性和方法。
         * 
         * Set类型的原型属性和方法如下。
            ·size：返回集合中元素的数量。
            ·add(value)：向集合中添加给定的值。
            ·clear()：清空集合。
            ·delete(value)：从集合中删除给定的值。
            ·has(value)：判断集合中是否存在给定的值。
            ·keys()：返回一个迭代器对象。可用于for...of循环，迭代器对象产生的值为集合中的元素值。
            ·values()：对于Set集合类型来说，keys()与values()等价。
            ·entries()：返回一个迭代器对象。迭代过程中为集合中的每一个元素产生一个数组值[value, value]。
            ·forEach(callback[, thisArg])：forEach函数会遍历集合中的所有元素，并对每一个元素调用callback函数。forEach函数接收可选的第二个参数thisArg，用于指定callback函数执行时的this值。
            
        * Map类型的原型属性和方法如下。
            ·size：返回Map数据中的键值对数量。
            ·clear()：清空Map。
            ·delete(key)：删除指定key的键值对。
            ·has(key)：判断Map中是否存在指定key的键值对。
            ·get(key)：读取指定key对应的值。
            ·set(key, value)：为Map设置新的键值对。
            ·keys()：返回一个迭代器对象。迭代过程中会产生键值对的key值。
            ·values()：返回一个迭代器对象。迭代过程中会产生键值对的value值。
            ·entries()：返回一个迭代器对象。迭代过程中会产生由[key, value]组成的数组值。
            ·forEach(callback[, thisArg])：forEach函数会遍历Map数据的所有键值对，并对每一个键值对调用callback函数。forEach函数接收可选的第二个参数thisArg，用于指定callback函数执行时的this值。
            
            
        * 观察上述列表可以发现，Map和Set这两个数据类型的操作方法相似。它们之间最大的不同体现:
        Set类型使用add(value)方法添加元素，而Map类型使用set(key, value)方法设置键值对，并且Map类型可以使用get(key)方法读取相应的值。
        既然两者如此相似，那么是不是意味着我们可以用相同的处理办法来实现对它们的代理呢？
        没错，接下来，我们就深入探讨如何实现对Set和Map类型数据的代理。
         * 
         * 
         * 
         * 
         * 
         */ 
    </script>
</body>
</html>